import React, { useEffect, useMemo, useState } from "react";
import "./App.css";

function uniqSorted(arr) {
  return Array.from(new Set(arr)).sort((a, b) => a.localeCompare(b));
}

function normalizeType(s) {
  return (s || "").trim();
}

export default function App() {
  const [availableVersions, setAvailableVersions] = useState([]);
  const [selectedVersion, setSelectedVersion] = useState("latest");

  const [raw, setRaw] = useState(null);
  const [loadError, setLoadError] = useState("");
  const [loadingIndex, setLoadingIndex] = useState(true);
  const [loadingData, setLoadingData] = useState(true);

  const [query, setQuery] = useState("");
  const [selectedType, setSelectedType] = useState("");

  // Load available versions list (generated by workflow)
  useEffect(() => {
    let cancelled = false;

    (async () => {
      setLoadingIndex(true);
      setLoadError("");

      try {
        const res = await fetch("/versions/index.json", { cache: "no-store" });
        if (!res.ok) throw new Error(`Failed to load versions/index.json (${res.status})`);
        const list = await res.json();
        if (!Array.isArray(list)) throw new Error("versions/index.json is not an array");

        if (!cancelled) setAvailableVersions(list);
      } catch (e) {
        if (!cancelled) setLoadError(String(e?.message || e));
      } finally {
        if (!cancelled) setLoadingIndex(false);
      }
    })();

    return () => {
      cancelled = true;
    };
  }, []);

  // Load dependency tree for selected version
  useEffect(() => {
    let cancelled = false;

    (async () => {
      setLoadingData(true);
      setLoadError("");

      try {
        const url =
          selectedVersion === "latest"
            ? "/dependency_tree.json"
            : `/versions/${selectedVersion}.json`;

        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error(`Failed to load ${url} (${res.status})`);

        const data = await res.json();
        if (!Array.isArray(data?.resources)) {
          throw new Error("Invalid dependency_tree JSON format");
        }

        if (!cancelled) {
          setRaw(data);
          setQuery("");
          setSelectedType("");
        }
      } catch (e) {
        if (!cancelled) setLoadError(String(e?.message || e));
      } finally {
        if (!cancelled) setLoadingData(false);
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [selectedVersion]);

  const { version, types, depsMap, reverseDepsMap } = useMemo(() => {
    const empty = {
      version: "",
      types: [],
      depsMap: new Map(),
      reverseDepsMap: new Map(),
    };
    if (!raw?.resources) return empty;

    const deps = new Map();
    const rev = new Map();

    for (const r of raw.resources) {
      const t = r?.type;
      if (!t) continue;

      const list = Array.isArray(r.dependencies) ? r.dependencies : [];
      if (!deps.has(t)) deps.set(t, new Set());

      for (const d of list) {
        if (!d) continue;
        deps.get(t).add(d);

        if (!rev.has(d)) rev.set(d, new Set());
        rev.get(d).add(t);
      }

      if (!rev.has(t)) rev.set(t, new Set());
    }

    return {
      version: raw.version || "",
      types: uniqSorted([...new Set([...deps.keys(), ...rev.keys()])]),
      depsMap: deps,
      reverseDepsMap: rev,
    };
  }, [raw]);

  const activeType = normalizeType(selectedType || query);

  const outgoing = useMemo(
    () => uniqSorted([...(depsMap.get(activeType) || [])]),
    [depsMap, activeType]
  );

  const incoming = useMemo(
    () => uniqSorted([...(reverseDepsMap.get(activeType) || [])]),
    [reverseDepsMap, activeType]
  );

  const suggestions = useMemo(() => {
    const q = normalizeType(query);
    if (!q) return types.slice(0, 60);
    const ql = q.toLowerCase();
    return types.filter((t) => t.toLowerCase().includes(ql)).slice(0, 60);
  }, [types, query]);

  const loading = loadingIndex || loadingData;

  return (
    <div className="page">
      <div className="card">
        <div className="headerRow">
          <div>
            <h1 className="h1">CX as Code – Resource Dependency Explorer</h1>
            <div className="subhead">
              Loaded provider version: <code className="code">{version || "(unknown)"}</code>
              <span className="subheadMuted">
                {" "}
                · History available back to <code className="code">1.60.0</code>
              </span>
            </div>
          </div>

          <div className="rightControls">
            <label className="label">Version</label>
            <select
              className="select"
              value={selectedVersion}
              onChange={(e) => setSelectedVersion(e.target.value)}
              disabled={loadingIndex}
            >
              <option value="latest">Latest</option>
              {availableVersions.map((v) => (
                <option key={v} value={v}>
                  {v}
                </option>
              ))}
            </select>
          </div>
        </div>

        <div className="controls">
          <input
            className="input"
            placeholder="genesyscloud_routing_queue"
            value={query}
            onChange={(e) => {
              setQuery(e.target.value);
              setSelectedType("");
            }}
            disabled={loading || !raw}
          />
        </div>

        {loadError ? <div className="error">{loadError}</div> : null}
        {loading ? <div className="muted">Loading CX as Code dependency data…</div> : null}

        {!loading && raw ? (
          <div className="grid">
            <div className="panel">
              <div className="panelTitle">
                Resources <span className="badge">{types.length}</span>
              </div>
              <div className="list">
                {suggestions.length === 0 ? (
                  <div className="muted">No matches.</div>
                ) : (
                  suggestions.map((t) => (
                    <button
                      key={t}
                      className={`listItem ${t === activeType ? "listItemActive" : ""}`}
                      onClick={() => {
                        setSelectedType(t);
                        setQuery(t);
                      }}
                      type="button"
                    >
                      <code className="code">{t}</code>
                    </button>
                  ))
                )}
              </div>
            </div>

            <div className="panel">
              <div className="panelTitle">Selected resource</div>

              <div className="selectedTypeRow">
                <code className="code codeBig">{activeType || "(none)"}</code>
                {activeType && !types.includes(activeType) ? (
                  <div className="warn">Not found in this version’s JSON.</div>
                ) : null}
              </div>

              <div className="twoCol">
                <div className="subPanel">
                  <div className="subTitle">
                    Depends on <span className="badge">{outgoing.length}</span>
                  </div>
                  {outgoing.length ? (
                    <ul className="ul">
                      {outgoing.map((d) => (
                        <li key={d}>
                          <code className="code">{d}</code>
                        </li>
                      ))}
                    </ul>
                  ) : (
                    <div className="muted">None.</div>
                  )}
                </div>

                <div className="subPanel">
                  <div className="subTitle">
                    Dependency for <span className="badge">{incoming.length}</span>
                  </div>
                  {incoming.length ? (
                    <ul className="ul">
                      {incoming.map((d) => (
                        <li key={d}>
                          <code className="code">{d}</code>
                        </li>
                      ))}
                    </ul>
                  ) : (
                    <div className="muted">None.</div>
                  )}
                </div>
              </div>
            </div>
          </div>
        ) : null}
      </div>
    </div>
  );
}